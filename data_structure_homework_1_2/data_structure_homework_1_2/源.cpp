//2．	编写递归函数，求n个元素集合的所有子集。不妨令集合元素为小写字母，原集合为{ ‘a’, ‘b’, …, ‘a’ + n - 1 }。
//输入：input.txt，仅包含整数n（1－26）。
//输出：若输入合法，输出集合的所有子集；否则输出“WRONG”。子集输出格式为每行一个子集，空集用空行表示，非空集合每个元素间用一个空格间隔，最后一个元素之后不能有空格。例如，对n = 3，可能的输出为：
//DDDDDDDDDDD
//
//a
//a b
//a b c
//a c
//b
//b c
//c
//
//提示：递归函数一般设计思路是将问题求解分为若干阶段，每个阶段有多种选择，则每个阶段尝试各种选择就构成函数主体，而“进入下一阶段”则用递归调用完成。对本问题，子集中包含元素的选择可作为“阶段”，而每个元素“是否在子集中”可作为“每个阶段的多种选择”。有个地方需要一些技巧：在何时安排输出，可达到要求的顺序？
//常用技巧：集合用什么样的数据结构保存、处理一般高级程序设计语言都不提供“集合”数据类型，因为集合大小不固定，且进行运算大小变化可能很剧烈。一般思路是用数组或链表（线性表）来保存集合，数组元素（链表节点）对应集合元素，集合运算的效率较差，可能会频繁改变数组、链表大小。但如果可能的集合元素是有限个，如本题，有一种较好的方法，仍然可用数组，但数组元素不是保存集合元素，而是每个数组元素固定对应一个可能的集合元素，数组元素类型是布尔值（t / f，0 / 1），表示对应元素是否包含在本集合内，显然本题用此方法很适合。还可进一步优化，由于每个数组元素值只可能是0 / 1，因此无需占用一个整型字，占用一位即可，这种“位表示法”的另一好处是将集合的操作转换为二进制位运算，效率非常高。比如，对本题，1101可能就表示{ a, c, d }（a－最低位），那么{ a, d, e, f }的位表示是什么？两个集合的并集用两个二进制数的什么运算即可完成？交集呢？如果使用这种方法，无需递归即可得到所有子集，当然，按题目要求，大家还应该设计递归函数。

#include<iostream>
using namespace std;
int n;
void print(char a[], int aa[], int begin, int end)
{
	for (int i = begin; i <= end; i++)
	{
		if (aa[i])
		{
			cout << a[i] << ' ';
		}

	}
	cout << endl;
}
void sonset(char a[], int aa[], int pos, int bo)
{
	if (pos <= n)
	{

		if (bo == 1)
		{
			aa[pos] = 1;
			print(a, aa, 1, n);
			sonset(a, aa, pos + 1, 1);
			sonset(a, aa, pos + 1, 0);
		}
		else
		{
			aa[pos] = 0;

			sonset(a, aa, pos + 1, 1);
			sonset(a, aa, pos + 1, 0);

		}

	}
	else
	{
		return;
	}


}
int main()
{
	try
	{
		cin >> n;
		char a[28];
		int aa[28];

		for (int i = 1; i <= 26; i++)
		{
			a[i] = ('a' + i - 1);
			aa[i] = 0;
		}

		sonset(a, aa, 1, 1);
		sonset(a, aa, 1, 0);



	}
	catch (exception& e)
	{
		cout << e.what() << endl;
	}

}